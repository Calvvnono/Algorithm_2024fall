/**
 * 思路分析：
 * 
 * 这个问题是一个多重背包问题的变形，包含三种不同类型的物品：
 * 
 * 1. **甲类物品（类型 1）：**
 *    - 价值随着分配给它的体积变化，价值函数为 \( V(x) = A x^2 - B x \)。
 *    - 我们需要枚举所有可能的体积分配 \( x \)（从 0 到当前背包容量 \( j \)），找到使得价值最大的组合。
 *    - 使用动态规划，外层循环遍历背包容量 \( j \)，内层循环遍历可能的体积分配 \( k \)。
 * 
 * 2. **乙类物品（类型 2）：**
 *    - 价值 \( A \) 和体积 \( B \) 固定，数量有限，为 \( C \) 个。
 *    - 使用多重背包的朴素实现，逐个处理每个物品，采用 0/1 背包的方式更新状态。
 * 
 * 3. **丙类物品（类型 3）：**
 *    - 价值 \( A \) 和体积 \( B \) 固定，数量无限。
 *    - 使用完全背包的方式处理，正序遍历背包容量，允许重复使用物品。
 * 
 * **动态规划实现：**
 * 
 * - 定义状态数组 `dp[j]`，表示容量为 \( j \) 时的最大总价值。
 * - 初始化 `dp[0] = 0`，其他位置初始化为一个较小的负数，表示不可达。
 * - 依次处理每个物品，根据物品类型采取不同的处理方式：
 *   - **甲类物品（类型 1）：**
 *     - 双重循环，外层从容量 \( j \) 递减到 0，内层从 0 遍历到 \( j \)。
 *     - 计算分配给该物品的体积 \( v = j - k \) 以及对应的价值。
 *     - 更新状态 `dp[j] = max(dp[j], dp[k] + 价值)`。
 *   - **乙类物品（类型 2）：**
 *     - 多重背包的朴素实现，逐个处理每个数量的物品。
 *     - 使用倒序遍历容量的方式，避免重复使用物品。
 *   - **丙类物品（类型 3）：**
 *     - 完全背包的方式，正序遍历容量，允许重复使用物品。
 */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int MAX_N = 105;   // 最大物品数量
const int MAX_M = 2005;  // 最大背包容量

int n, m;
int id[MAX_N];        // 物品类型
int A[MAX_N];         // 对于类型1：系数A；对于类型2和3：价值A
int B[MAX_N];         // 对于类型1：系数B；对于类型2和3：体积B
int C[MAX_N];         // 对于类型2：数量C；对于类型1和3：未使用
int dp[MAX_M];        // 动态规划数组

int main() {
    scanf("%d%d", &n, &m);

    // 读取物品信息
    for (int i = 1; i <= n; i++) {
        scanf("%d", &id[i]);
        if (id[i] == 1) {
            // 类型1物品
            scanf("%d%d", &A[i], &B[i]); // 系数A和B
        } else if (id[i] == 2) {
            // 类型2物品
            scanf("%d%d%d", &A[i], &B[i], &C[i]); // 价值A，体积B，数量C
        } else if (id[i] == 3) {
            // 类型3物品
            scanf("%d%d", &A[i], &B[i]); // 价值A，体积B
        }
    }

    // 初始化动态规划数组
    memset(dp, -0x3f, sizeof(dp)); // 初始化为一个很小的负数
    dp[0] = 0;

    // 处理每个物品
    for (int i = 1; i <= n; i++) {
        if (id[i] == 1) {
            // 类型1物品
            // 遍历背包容量，从大到小
            for (int j = m; j >= 0; j--) {
                // 枚举可能的前一个容量k（从0到j）
                for (int k = 0; k <= j; k++) {
                    int v = j - k; // 分配给该物品的体积
                    int value = A[i] * v * v - B[i] * v; // 计算价值
                    dp[j] = max(dp[j], dp[k] + value);
                }
            }
        } else if (id[i] == 2) {
            // 类型2物品（数量有限）
            // 每一组物品就是 C[i] 个 01 背包
            for (int k = 1; k <= C[i]; k++) {
                // 0/1背包，倒序遍历容量
                for (int j = m; j >= B[i]; j--) {
                    dp[j] = max(dp[j], dp[j - B[i]] + A[i]);
                }
            }
        } else if (id[i] == 3) {
            // 类型3物品（数量无限）
            // 完全背包，正序遍历容量
            for (int j = B[i]; j <= m; j++) {
                dp[j] = max(dp[j], dp[j - B[i]] + A[i]);
            }
        }
    }

    // 输出背包容量为m时的最大价值
    printf("%d\n", dp[m]);

    return 0;
}
